// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider        = "prisma-client-js"
  output          = "../src/generated/prisma"
  binaryTargets   = ["native", "rhel-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model
model User {
  id                       String         @id @default(uuid())
  email                    String         @unique
  password                 String? // Hashed password
  name                     String? // User's display name
  createdAt                DateTime       @default(now()) @map("created_at")
  lastLogin                DateTime?      @map("last_login")
  isActive                 Boolean        @default(true) @map("is_active")
  preferences              Json           @default("{}")
  emailVerified            Boolean        @default(false) @map("email_verified")
  verificationToken        String?        @map("verification_token")
  verificationTokenExpires DateTime?      @map("verification_token_expires")
  resetPasswordToken       String?        @map("reset_password_token")
  resetPasswordExpires     DateTime?      @map("reset_password_expires")
  role                     String         @default("user") // Can be "user", "admin", etc.
  sessions                 Session[]
  profile                  UserProfile?
  mvpCharacters            MVPCharacter[] // Relation to MVPCharacter

  @@map("users")
}

// User Profile model - for additional user data
model UserProfile {
  id          String   @id @default(uuid())
  userId      String   @unique @map("user_id")
  name        String
  avatarUrl   String?  @map("avatar_url")
  bio         String?
  preferences Json     @default("{}")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

// Session model - for keeping track of user sessions
model Session {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  token      String?  @unique
  expires    DateTime
  userAgent  String?  @map("user_agent")
  ip         String?
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")
  lastActive DateTime @default(now()) @map("last_active")
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("sessions")
}

// --- MVP MODELS ---

model MVPCharacter {
  id                    String    @id @default(uuid())
  userId                String    @map("user_id")
  name                  String
  backstory             String?
  appearanceDescription String?   @map("appearance_description")
  personalityTraits     Json      @default("[]") @map("personality_traits") // Matches MVPCharacter.personalityTraits: string[]
  createdAt             DateTime  @default(now()) @map("created_at")
  lastPlayedAt          DateTime? @map("last_played_at")
  isActive              Boolean   @default(true) @map("is_active")

  user                    User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  mvpCharacterWorldStates MVPCharacterWorldState[]
  simplifiedGameStates    SimplifiedGameState[]

  @@unique([userId, name])
  @@index([userId])
  @@map("mvp_characters")
}

model MVPWorld {
  id           String   @id @default(uuid())
  name         String
  description  String?
  thumbnailUrl String?  @map("thumbnail_url")
  isActive     Boolean  @default(true) @map("is_active")
  createdAt    DateTime @default(now()) @map("created_at")

  mvpLocations            MVPLocation[]
  mvpLoreFragments        MVPLoreFragment[]
  mvpCharacterWorldStates MVPCharacterWorldState[]
  simplifiedGameStates    SimplifiedGameState[]
  MVPEvent                MVPEvent[]

  @@map("mvp_worlds")
}

model MVPCharacterWorldState {
  characterId     String    @map("character_id")
  worldId         String    @map("world_id")
  currentLocation String?   @map("current_location") // As per MVPCharacterWorldState type
  lastPlayedAt    DateTime? @map("last_played_at")

  character MVPCharacter @relation(fields: [characterId], references: [id], onDelete: Cascade)
  world     MVPWorld     @relation(fields: [worldId], references: [id], onDelete: Cascade)

  @@id([characterId, worldId]) // Composite primary key
  @@map("mvp_character_world_states")
}

model MVPLocation {
  id                   String   @id @default(uuid())
  worldId              String   @map("world_id")
  name                 String
  description          String?
  isStartingLocation   Boolean  @default(false) @map("is_starting_location")
  connectedLocationIds String[] @map("connected_location_ids") // Matches MVPLocation.connectedLocationIds: string[]
  dangerLevel          String?  @map("danger_level")
  thumbnailUrl         String?  @map("thumbnail_url")

  world    MVPWorld   @relation(fields: [worldId], references: [id], onDelete: Cascade)
  MVPEvent MVPEvent[]

  @@unique([worldId, name])
  @@map("mvp_locations")
}

model MVPLoreFragment {
  id         String   @id @default(uuid())
  worldId    String   @map("world_id")
  title      String
  content    String
  type       String? // Optional as per MVP plan (prioritize core fields)
  locationId String?  @map("location_id") // Optional 
  contextId  String?  @map("context_id") // Optional
  isRevealed Boolean  @default(true) @map("is_revealed")
  keywords   String[] @default([]) @map("keywords") // Matches MVPLoreFragment.keywords: string[]

  world MVPWorld @relation(fields: [worldId], references: [id], onDelete: Cascade)

  @@map("mvp_lore_fragments")
}

model MVPEvent {
  id                String  @id @default(uuid())
  worldId           String  @map("world_id")
  locationId        String? @map("location_id")
  title             String
  description       String
  eventType         String
  triggerConditions Json    @map("trigger_conditions")
  outcomes          Json    @map("outcomes")
  isRepeatable      Boolean @default(false) @map("is_repeatable")

  world    MVPWorld     @relation(fields: [worldId], references: [id], onDelete: Cascade)
  location MVPLocation? @relation(fields: [locationId], references: [id], onDelete: Cascade)

  @@map("mvp_events")
}

model SimplifiedGameState {
  id                String   @id @default(uuid())
  sessionId         String // Plan: simple UUID string, not a direct FK for MVP
  characterId       String   @map("character_id")
  worldId           String   @map("world_id")
  turnNumber        Int
  characterState    Json     @map("character_state") // Stores MVPCharacterState (subset of fields)
  worldState        Json     @map("world_state") // Stores MVPWorldState (subset of fields)
  currentLocationId String   @map("current_location_id") // ID of an MVPLocation
  narrativeLog      Json     @map("narrative_log") // Stores NarrativeLogEntry[]
  currentChoices    Json     @map("current_choices") // Stores string[]
  lastModified      DateTime @map("last_modified")
  currentObjective  String?  @map("current_objective")

  character MVPCharacter @relation(fields: [characterId], references: [id], onDelete: Cascade)
  world     MVPWorld     @relation(fields: [worldId], references: [id], onDelete: Cascade)
  // currentLocationId is an ID string, not a direct relation here to keep it simple as per plan.

  @@index([sessionId])
  @@index([characterId])
  @@index([worldId])
  @@index([lastModified])
  @@map("simplified_game_states")
}
