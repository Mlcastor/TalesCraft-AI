---
description: Use this rule if you ever need to implement, create or integrate an UI component.
globs: 
---

# State Access Patterns

This document outlines the state access patterns implemented in the Tales Craft AI codebase to standardize state access across components and optimize rendering performance.

## Overview

The state access patterns implemented follow these principles:

1. **Single Source of Truth**: Game state is managed by the `GameEngineProvider`, UI state is managed by the `GameUIContext`, settings are managed by `GameSettingsProvider`, and narrative is managed by `NarrativeContext`.
2. **Selective State Access**: Components should only access the specific parts of state they need.
3. **Optimized Rendering**: State selectors ensure components only re-render when relevant state changes.
4. **Consistent Access Patterns**: Standard patterns for accessing state across the application.

## Implementation

We've implemented the following key components for state access:

### 1. Selector Hooks

Specialized hooks that provide access to specific pieces of state:

- **GameEngine Selectors**: Hooks for accessing specific parts of game engine state
- **GameUI Selectors**: Hooks for accessing specific parts of UI state
- **GameSettings Selectors**: Hooks for accessing specific parts of game settings
- **Narrative Selectors**: Hooks for accessing specific parts of narrative state

### 2. Selector Utilities

Utility functions for creating custom selectors when needed:

- `useSelector`: Creates a selector that only re-renders when dependencies change
- `useStateSelector`: Creates a selector for state objects
- `useShallowSelector`: Creates a selector for selected properties of an object
- `useBooleanSelector`: Creates a selector for boolean conditions

## Using Selectors

### Basic Usage

Instead of accessing contexts directly:

```tsx
// ❌ Avoid this
const { currentState } = useGameEngine();
const character = currentState?.characterState;

// ❌ Avoid this
const { settings } = useGameSettings();
const fontSize = settings.fontSize;

// ❌ Avoid this
const { narrativeText, isTyping } = useNarrativeContext();
```

Use specialized selector hooks:

```tsx
// ✅ Use this
const character = useCharacterState();

// ✅ Use this
const { fontSize } = useDisplaySettings();

// ✅ Use this
const { narrativeText, isTyping } = useNarrativeTextState();
```

### Compound Selectors

For complex components that need multiple pieces of state:

```tsx
// ✅ Use specific selectors for each piece of state
const isGameActive = useGameActiveStatus();
const worldState = useWorldState();
const { isGameStateExpanded } = useUIViewState();
const { toggleGameStatePanel } = useUIToggleActions();
const { textSpeed } = useDisplaySettings();
const narrativeHistory = useNarrativeHistory();
```

### Benefits of Selectors

1. **Performance**: Components only re-render when relevant state changes
2. **Clarity**: Component dependencies are clearly visible
3. **Maintainability**: State access is consistent across components
4. **Testability**: Easier to mock selected state for testing

## Available Selectors

### Game Engine Selectors

| Selector | Description | Returns |
|----------|-------------|---------|
| `useGameActiveStatus` | Active status of the game | `boolean` |
| `useCurrentWorldId` | Current world ID | `string \| undefined` |
| `useCurrentCharacterId` | Current character ID | `string \| undefined` |
| `useGameEngineLoading` | Loading state | `boolean` |
| `useGameEngineError` | Error state | `string \| null` |
| `useGameEngineClearError` | Error clearing function | `() => void` |
| `useGameCurrentState` | Current session and state | `{ session: GameSession \| null, state: GameState \| null }` |
| `useCharacterState` | Character state | `Record<string, any> \| null` |
| `useWorldState` | World state | `Record<string, any> \| null` |
| `useCurrentLocation` | Current location | `string \| null` |
| `useNarrativeState` | Narrative state | `NarrativeState \| null` |
| `useDecisionsState` | Available decisions | `Decision[] \| null` |
| `useSaveGame` | Save game function | `Function` |
| `useMakeDecision` | Make decision function | `Function` |

### Game UI Selectors

| Selector | Description | Returns |
|----------|-------------|---------|
| `useUIViewState` | UI view state | `ViewState` |
| `useUILoadingState` | UI loading state | `LoadingState` |
| `useUIFeedbackState` | UI feedback state | `FeedbackState` |
| `useUINarrativeState` | UI narrative display state | `NarrativeDisplayState` |
| `useUILayoutState` | UI layout state | `LayoutState` |
| `useUISelectors` | Pre-computed selectors | `{ isPanelActive, isLoading, hasFeedback }` |
| `useUIToggleActions` | UI toggle functions | Various toggle functions |
| `useUISetterActions` | UI setter functions | Various setter functions |
| `useUIStateUpdater` | Generic state updater | `(updates: Partial<GameUIState>) => void` |

### Game Settings Selectors

| Selector | Description | Returns |
|----------|-------------|---------|
| `useAllGameSettings` | All game settings | `GameSettings` |
| `useDisplaySettings` | Display settings | `{ fontSize, textSpeed, highContrast }` |
| `useAudioSettings` | Audio settings | `{ musicVolume, soundEffectsVolume, textToSpeechEnabled }` |
| `useAccessibilitySettings` | Accessibility settings | `{ keyboardShortcutsEnabled, hapticFeedbackEnabled, highContrast, autoSaveEnabled }` |
| `useContentSettings` | Content settings | `{ showConsequences, autoSaveInterval }` |
| `useSettingsActions` | Settings action functions | `{ updateSettings, resetSettings }` |

### Narrative Selectors

| Selector | Description | Returns |
|----------|-------------|---------|
| `useNarrativeTextState` | Narrative text and typing status | `{ narrativeText, isTyping }` |
| `useNarrativeHistory` | Narrative history | `Array<NarrativeHistoryEntry>` |
| `useRecentNarrativeHistory` | Recent narrative history | `Array<NarrativeHistoryEntry>` |
| `useNarrativeTextActions` | Text manipulation actions | Various functions |
| `useNarrativeHistoryActions` | History manipulation actions | Various functions |
| `useNarrativeSpeech` | Speech state and controls | `{ isSpeaking, toggleTextToSpeech }` |
| `useNarrativeScrollRef` | Reference to narrative scroll element | `RefObject` |

## Best Practices

1. **Granular Selection**: Use the most specific selector for your needs
2. **Component Memoization**: Combine with `React.memo()` for optimal performance
3. **Selector Composition**: Build more complex selectors from basic ones
4. **Fallback Values**: Always handle the case where selector returns null or undefined
5. **Prop vs. Selector**: For flexibility, allow components to receive props that override selector values

## Example

```tsx
import { memo } from "react";
import { useCharacterState, useWorldState } from "@/hooks/game/useGameEngineSelectors";
import { useUIToggleActions } from "@/hooks/game/useGameUISelectors";
import { useDisplaySettings } from "@/hooks/game/useGameSettingsSelectors";

const GameComponent = memo(() => {
  // Use selectors for specific state access
  const character = useCharacterState();
  const world = useWorldState();
  const { fontSize } = useDisplaySettings();
  
  // Use UI actions
  const { toggleGameStatePanel } = useUIToggleActions();
  
  // Component only re-renders when the specific state it uses changes
  return (
    <div className={`text-${fontSize}`}>
      <h2>{character?.name || "Unknown Character"}</h2>
      <p>World: {world?.name || "Unknown World"}</p>
      <button onClick={toggleGameStatePanel}>Toggle Panel</button>
    </div>
  );
});
```

## Implemented Components

These components have been refactored to use selector hooks:

1. **GameStateDisplay**: Uses `useGameActiveStatus`, `useGameEngineLoading`, and `useGameCurrentState` selectors for optimized rendering.

2. **GameStateBar**: Uses selectors as fallbacks when props aren't provided and works with the UI toggles through `useUIToggleActions`.

3. **GameStateExpanded**: Uses game engine selectors for state access and UI selectors for toggling panels.

4. **UIOptimizedPanel**: Demonstrates comprehensive use of selectors from multiple contexts.

5. **GameSettingsPanel**: Uses `useAllGameSettings` and `useSettingsActions` instead of direct context access.

6. **NarrativeDisplay**: Uses specialized narrative selectors to optimize rendering.

## Migration Strategy

1. Identify components that access context directly
2. Replace direct context access with appropriate selectors
3. Use `React.memo()` to optimize component rendering
4. Allow props to override selector values where appropriate
5. Test performance before and after to measure improvements 